# -*- coding: utf-8 -*-
"""Infixada/Posfixada - Adaptada.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uIJ09FLwBwFQ-MJEQZWYBbj4FzPrMChS
"""

pip install pythonds

"""1. Crie uma pilha vazia chamada opstack para manter os operadores. Cria uma lista vazia para a saída.

2. Converta a string infixa input para uma lista usando o método split().

3. Examine os itens da lista da esquerda para a direita.

  3.1 Se o item é um operador, coloque-o no final da lista da saída.

  3.2 Se o item é um abre parêntese, insira-o (push()) na pilha opstack.

  3.3 Se o item é um fecha parênteses, remova ( pop()) os itens de opstack até que o abre parêntese correspondente seja removido. Coloque cada operador removido no final da lista da saída.

  3.4Se i item é um operador, *, /, +, or -, insira-o na pilha opstack. Entretanto, remova antes os operadores que estão na pilha que têm precedência maior ou igual ao operador encontrado e coloque-os na final da lista da saída.

4. Quando a expressão tiver sido completamente examinada, verifique opstack. Qualquer operador que ainda está na pilha deve ser removido e colocado na lista da saída..
"""

#Fonte: https://panda.ime.usp.br/pythonds/static/pythonds_pt/03-EDBasicos/09-ExpressoesInfixaPrefixaPosfixa.html

from pythonds.basic.stack import Stack

#Função que retorna a notação pós-fixada
def infixadaparaposfixada(expressao):
    dicionary = {"*": 3, "/": 3, "+": 2, "-": 2, "(": 1} #Criação de um dicionário com os pesos de cada possível caractere
    pilha = Stack()                        #uso de uma pilha, estrutura python
    
    listaposfixada = []
    tokenizando = expressao.split()         #transforma a entrada em uma lista
    
    for token in tokenizando:              
        if token in "0123456789":           
            listaposfixada.append(token)    #Se o caracetere for um número adiciona na lista pos-fixada diretamente
            
        elif token == '(':
            pilha.push(token)              #Se for '(' adiciona na pilha 
            
        elif token == ')':                  
            topotoken = pilha.pop()        #Se for ')' adiciona na variavel topotoken e remove da pilha
            
            while topotoken != '(':        #Enquanto não encontrar o '(' correspondente do ')' da linha 25
                listaposfixada.append(topotoken) #Pega o caracetere e adiciona na lista pos-fixada diretamente
                topotoken = pilha.pop() #Apaga ele da pilha
                
        else: #Se o token for um desses operadores " * - / - + - -"
            while (not pilha.isEmpty()) and (dicionary[pilha.peek()] >= dicionary[token]): #enquanto a pilha não for vazia e o topo da pilha (com base no dicionario) tiver um valor >= que o valor do token
                  listaposfixada.append(pilha.pop()) #Adiciono ele na lista de saída e excluo ele da pilha
                  
            pilha.push(token) #se ele não "cair" no while acima, é porque ou a pilha está vazia e eu preciso adicionar o token na pilha, ou porque o token que está no topo da pilha é menor que o token que está no for
            

    while not pilha.isEmpty(): #aqui entra se já fez todo o processamento e a pilha ainda contém tokens
        listaposfixada.append(pilha.pop()) #adiciona na lista de saída e exclui o token em questão da pilha
    return " ".join(listaposfixada) #retorno a expressão pós fixada :)

#entradasteste = "1*2/3" "1/2*3+4*5-1*3" "(1/2)*(3+4)*(5-1)*3"
entrada= "(1/2)*(3+4)*(5-1)*3" #entrada padrão
expressaoinput = "" #expressão que será passada para pos fixada (criada vazia para fazer um tratamento de string)
for i in entrada:
  expressaoinput += i + " " # acrescenta um espaço " " entre cada caracter
expressaoinput.rstrip() #retira o ultimo espaço

print('Expressão infixada: ', (entrada))
print('Expressão pós-fixada: ', (infixadaparaposfixada(expressaoinput))) #chama a função e passa para ela a expressão infixa